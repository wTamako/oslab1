# oslab1
1. 理解内核启动中的程序入口操作
1.1. 指令：la sp, bootstacktop

    la 是 MIPS 汇编中的伪指令，用于加载地址到寄存器。
    sp 通常指向栈顶的寄存器，保存当前栈的顶部地址。
    bootstacktop 是一个全局符号，表示内核的启动栈的顶部地址。
    目的：将内核的启动栈的顶部地址加载到寄存器 sp 中，以便操作系统内核的执行可以开始使用这个栈。

1.2. 指令：tail kern_init

    tail 是 MIPS 汇编中的伪指令，用于跳转到一个函数或标签，并销毁当前函数的栈帧，以避免函数调用的嵌套。
    kern_init 表示内核初始化函数的入口点。
    目的：跳转到内核初始化函数 kern_init，销毁启动代码的栈帧，将控制权传递给内核初始化函数，从而有效地启动内核，而不需要额外的栈空间用于启动代码。
    
2. 理解上下文切换机制
   
2.1.指令：csrw sscratch, sp

    这条指令将当前的栈指针（sp 寄存器的值）保存到 sscratch 控制状态寄存器（CSR）中。
    目的：将当前的栈指针值保存在 sscratch 寄存器中，以备将来的上下文切换使用。sscratch 寄存器通常用于保存临时状态信息，以便在异常或中断处理期间保存寄存器的状态。

2.2. 指令：csrrw s0, sscratch, x0

    这条指令将 x0 寄存器的值（一般为零）加载到 sscratch 寄存器中，并将 sscratch 寄存器的原始值存储在 s0 寄存器中。
    目的：清除 sscratch 寄存器，以确保不会在后续的代码中不经意地使用了保存在其中的栈指针值。

2.3.RESTORE_ALL 中没有恢复它们的原因是这些 CSR 的值在异常处理过程中是只读的，它们用于指示异常的原因和相关信息，而不是用于修改的。在异常处理过程中，通常不需要修改这些 CSR 的值，而只需要读取它们以便了解异常的原因和附加信息。因此，在 SAVE_ALL 中保存这些 CSR 的值是为了记录异常发生时的状态，但在 RESTORE_ALL 中不需要恢复它们.

3. 描述与理解中断流程
3.1. 异常的产生

    异常可以由不同的原因产生，包括硬件错误、系统调用、外部中断等。
    异常通常会导致处理器从用户模式切换到内核模式，以执行相应的异常处理程序。

3.2. 异常处理入口

    在 ucore 中，通常使用一个名为 __alltraps 的汇编标签作为异常处理程序的入口点。
    这是一个通用的入口点，用于处理所有的异常和中断。

3.3. 保存寄存器

    在 __alltraps 中，首先会执行 SAVE_ALL 宏，它保存了所有的通用寄存器和一些特殊的控制寄存器到栈中。
    这些寄存器包括通用寄存器 x0 到 x31，以及控制寄存器 sscratch、sstatus、sepc、sbadaddr 和 scause 的值。
    mov a0, sp 指令将栈指针的值（sp 寄存器的内容）保存在寄存器 a0 中，以便在异常处理过程中，如果需要访问栈上的参数或者保存现场，可以方便地使用 a0 来引用栈指针的值。

3.4. 异常处理

    在 __alltraps 中，通常会调用一个名为 trap 的 C 函数，这个函数负责实际的异常处理。
    根据 scause 寄存器的值，可以确定异常的原因。

3.5. 恢复寄存器

    在异常处理完成后，会执行 RESTORE_ALL 宏，它恢复之前保存的寄存器状态，包括通用寄存器和控制寄存器。
    这个过程会使用之前保存的 sp 寄存器的值，将栈上的数据重新加载到寄存器中。

3.6. 返回到用户模式

    最后，通过 sret 指令或类似的方式，将控制返回到用户模式，继续用户程序的执行。

mov a0, sp 的目的是将栈指针的值保存在 a0 中，以便在异常处理过程中可以方便地引用栈指针的值。

SAVE_ALL 中寄存器保存在栈中的位置通常是在 sp 寄存器的偏移量上，每个寄存器占用一个固定大小的空间，这个大小通常由硬件架构决定。这个具体的偏移量和大小在汇编代码中是根据 REGBYTES 定义的，通常是一个寄存器的大小。因此，每个寄存器在栈中的位置是根据其在寄存器文件中的编号来确定的。

对于任何中断，__alltraps 中都需要保存所有寄存器的原因是，异常或中断可能会发生在任何时刻，并且需要保证内核能够正确地处理异常并保存用户程序的状态。不同类型的异常可能需要不同的寄存器状态来进行处理，因此在 __alltraps 中保存所有寄存器可以确保不会丢失重要的上下文信息。此外，这种一般性的处理方式可以简化异常处理的逻辑
